/*
 * MIT License
 *
 * Copyright (c) 2020-present Cloudogu GmbH and Contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package com.cloudogu.repositoryavatar;

import com.google.common.io.Resources;
import org.apache.commons.io.FileUtils;
import org.apache.shiro.authz.UnauthorizedException;
import org.apache.shiro.subject.Subject;
import org.apache.shiro.util.ThreadContext;
import org.jboss.resteasy.mock.MockHttpRequest;
import org.jboss.resteasy.mock.MockHttpResponse;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import sonia.scm.repository.Repository;
import sonia.scm.repository.RepositoryManager;
import sonia.scm.repository.RepositoryTestData;
import sonia.scm.web.RestDispatcher;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.RandomAccessFile;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.UUID;

import static com.cloudogu.repositoryavatar.AvatarResource.MEDIA_TYPE;
import static java.util.Collections.singletonMap;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;


@ExtendWith(MockitoExtension.class)
class AvatarResourceTest {

  private static final Repository REPOSITORY = RepositoryTestData.createHeartOfGold();

  @Mock
  private RepositoryManager repositoryManager;
  @Mock
  private AvatarStore avatarStore;

  RestDispatcher dispatcher;
  MockHttpResponse response = new MockHttpResponse();

  @Mock
  private Subject subject;

  @BeforeEach
  void init() {
    AvatarResource resource = new AvatarResource(repositoryManager, avatarStore);
    dispatcher = new RestDispatcher();
    dispatcher.addSingletonResource(resource);

    when(repositoryManager.get(REPOSITORY.getNamespaceAndName())).thenReturn(REPOSITORY);
    ThreadContext.bind(subject);
  }

  @AfterEach
  void tearDown() {
    ThreadContext.unbindSubject();
  }

  @Test
  void shouldSaveAutoGeneratedAvatar() throws URISyntaxException {
    MockHttpRequest request = MockHttpRequest
      .post("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/auto-generated");

    dispatcher.invoke(request, response);

    verify(avatarStore).saveAvatar(eq(REPOSITORY), argThat(avatar -> {
      assertThat(avatar.getType()).isEqualTo(AvatarType.AUTO_GENERATED);
      return true;
    }));
  }

  @Test
  void shouldSavePredefinedAvatar() throws URISyntaxException {
    MockHttpRequest request = MockHttpRequest
      .post("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/predefined")
      .contentType(MEDIA_TYPE)
      .content("{\"iconName\" : \"poo\", \"color\" : \"pink\"}".getBytes());

    dispatcher.invoke(request, response);

    assertThat(response.getStatus()).isEqualTo(204);

    verify(avatarStore).saveAvatar(eq(REPOSITORY), argThat(avatar -> {
      assertThat(avatar.getType()).isEqualTo(AvatarType.PREDEFINED);
      assertThat(avatar.getColor()).isEqualTo("pink");
      assertThat(avatar.getIconName()).isEqualTo("poo");
      return true;
    }));
  }

  @Test
  void shouldThrowUnauthorizedExceptionForPredefinedAvatar() throws URISyntaxException {
    MockHttpRequest request = MockHttpRequest
      .post("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/predefined")
      .contentType(MEDIA_TYPE)
      .content("{\"iconName\" : \"poo\", \"color\" : \"pink\"}".getBytes());

    doThrow(UnauthorizedException.class).when(subject).checkPermission("repository:modify:" + REPOSITORY.getId());
    dispatcher.invoke(request, response);

    assertThat(response.getStatus()).isEqualTo(403);
  }

  @Test
  void shouldUploadAvatar() throws URISyntaxException, IOException {
    File avatarFile = Paths.get(Resources.getResource("cloudogu/scm/repositoryavatar/avatar.gif").toURI()).toFile();

    try (FileInputStream fis = new FileInputStream(avatarFile)) {
      MockHttpRequest request = MockHttpRequest
        .post("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/uploaded");
      multipartRequest(request, singletonMap("file", fis), "image/gif");

      dispatcher.invoke(request, response);
    }

    assertThat(response.getStatus()).isEqualTo(204);

    verify(avatarStore).saveAvatar(eq(REPOSITORY), argThat(avatar -> {
      assertThat(avatar.getMediaType()).isEqualTo("image/gif");
      assertThat(avatar.getImage().length).isEqualTo(3675);
      return true;
    }));
  }

  @Test
  void shouldNotUploadInvalidAvatarFormat(@TempDir Path temp) throws URISyntaxException, IOException {
    File avatarFile = Files.createFile(temp.resolve("avatar.xyz")).toFile();

    try (FileInputStream fis = new FileInputStream(avatarFile)) {
      MockHttpRequest request = MockHttpRequest
        .post("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/uploaded");
      multipartRequest(request, singletonMap("file", fis), "invalid/xyz");

      dispatcher.invoke(request, response);
    }

    assertThat(response.getStatus()).isEqualTo(400);
  }

  @Test
  void shouldNotUploadTooLargeAvatar(@TempDir Path temp) throws URISyntaxException, IOException {
    File avatarFile = Files.createFile(temp.resolve("avatar.gif")).toFile();

    RandomAccessFile bigAvatar = new RandomAccessFile(avatarFile, "rw");
    bigAvatar.setLength(6000000);
    bigAvatar.close();

    try (FileInputStream fis = new FileInputStream(avatarFile)) {
      MockHttpRequest request = MockHttpRequest
        .post("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/uploaded");
      multipartRequest(request, singletonMap("file", fis), "image/gif");

      dispatcher.invoke(request, response);
    }

    assertThat(response.getStatus()).isEqualTo(400);
  }

  @Test
  void shouldGetUploadedAvatar() throws URISyntaxException, IOException {
    File avatarFile = Paths.get(Resources.getResource("cloudogu/scm/repositoryavatar/avatar.gif").toURI()).toFile();
    byte[] imageBytes = FileUtils.readFileToByteArray(avatarFile);
    when(avatarStore.getAvatar(REPOSITORY)).thenReturn(Avatar.uploaded(imageBytes, "image/png"));

    MockHttpRequest request = MockHttpRequest
      .get("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/uploaded");

    dispatcher.invoke(request, response);

    assertThat(response.getStatus()).isEqualTo(200);
    assertThat(response.getOutputHeaders().getFirst("content-disposition").toString()).contains("avatar");
  }

  @Test
  void shouldThrowNotFoundIfNoImageExists() throws URISyntaxException {
    when(avatarStore.getAvatar(REPOSITORY)).thenReturn(Avatar.uploaded(null, "image/png"));

    MockHttpRequest request = MockHttpRequest
      .get("/v2/repository-avatar/" + REPOSITORY.getNamespaceAndName() + "/uploaded");

    dispatcher.invoke(request, response);

    assertThat(response.getStatus()).isEqualTo(404);
  }

  /**
   * This method is a slightly adapted copy of Lin Zaho's gist at https://gist.github.com/lin-zhao/9985191
   */
  static void multipartRequest(MockHttpRequest request, Map<String, InputStream> files, String mediaType) throws IOException {
    String boundary = UUID.randomUUID().toString();
    request.contentType("multipart/form-data; boundary=" + boundary);

    //Make sure this is deleted in afterTest()
    ByteArrayOutputStream buffer = new ByteArrayOutputStream();
    try (OutputStreamWriter formWriter = new OutputStreamWriter(buffer)) {
      formWriter.append("--").append(boundary);

      for (Map.Entry<String, InputStream> entry : files.entrySet()) {
        formWriter.append("\n");
        formWriter.append(String.format("Content-Disposition: form-data; name=\"%s\"; filename=\"%s\"",
          entry.getKey(), entry.getKey())).append("\n");
        formWriter.append("Content-Type: " + mediaType).append("\n\n");

        InputStream stream = entry.getValue();
        int b = stream.read();
        while (b >= 0) {
          formWriter.write(b);
          b = stream.read();
        }
        stream.close();
        formWriter.append("\n").append("--").append(boundary);
      }

      formWriter.append("--");
      formWriter.flush();
    }
    request.setInputStream(new ByteArrayInputStream(buffer.toByteArray()));
  }
}
